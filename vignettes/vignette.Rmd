---
title: "vignette"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(heleramcar6)
```

#' # Introduction
#' The Knapsack Problem is a classic combinatorial optimization problem. Given a set of items with weights and values, the goal is to determine the combination of items that maximizes the total value without exceeding a maximum weight capacity.
#' 
#' In this vignette, we will explore how to solve the Knapsack Problem using different approaches:
#' - *Brute Force*: Testing all possible combinations of items.
#' - *Greedy Heuristic*: A fast but suboptimal approximation.
#' - *Dynamic Programming*: An efficient approach for finding the optimal solution.
#' 
#' # Brute-Force Solution
#' The brute-force method tries every possible subset of items, calculating their total weight and value. It then compares the values of valid solutions (those within the weight limit) to find the maximum value. While accurate, this method is computationally expensive and not suitable for large numbers of items due to its exponential time complexity.

```r
# Define the brute-force knapsack function
brute_force_knapsack <- function(x, W) {
  # Number of items
  n <- nrow(x)
  
  # Initialize solution variables
  value <- 0
  elements <- vector()
  
  # Iterate over all possible combinations (2^n - 1 subsets)
  for (i in 1:(2^n - 1)) {
    mask <- as.logical(intToBits(i)[1:n])
    x_true <- x[mask, ]
    
    x_true_weight <- sum(x_true$w)
    x_true_value <- round(sum(x_true$v))
    
    # Check if this subset is valid and better than the current best
    if (x_true_weight <= W & x_true_value > value) {
      value <- x_true_value
      elements <- which(mask)
    }
  }
  
  return(list(value = value, elements = elements))
}

# Example usage
items <- data.frame(w = c(2, 3, 4, 5), v = c(3, 4, 5, 6))
W <- 5
brute_force_knapsack(items, W)
```


#' # Greedy Heuristic Solution #' The greedy heuristic approach is faster but does not guarantee an optimal solution. It selects items based on their value-to-weight ratio, adding them to the knapsack as long as they fit without exceeding the capacity. This approach can lead to suboptimal solutions but is efficient for large datasets.

# Define the greedy knapsack function
greedy_knapsack <- function(x, W) {
  # Add a value-to-weight ratio column
  x$ratio <- x$v / x$w
  
  # Sort items by this ratio in decreasing order
  x <- x[order(x$ratio, decreasing = TRUE), ]
  
  value <- 0
  weight <- 0
  elements <- c()
  
  for (i in 1:nrow(x)) {
    if (weight + x$w[i] <= W) {
      value <- value + x$v[i]
      weight <- weight + x$w[i]
      elements <- c(elements, i)
    } else {
      break
    }
  }
  
  return(list(value = round(value), elements = elements))
}

# Example usage
greedy_knapsack(items, W)

#' # Dynamic Programming Solution #' The dynamic programming solution efficiently solves the knapsack problem by building a table where each entry represents the maximum value achievable with a given weight capacity and a subset of items. This method ensures an optimal solution, though it is more computationally intensive than the greedy approach but much faster than brute force.

# Define the dynamic programming knapsack function
knapsack_dynamic <- function(x, W) {
  N <- nrow(x)
  
  # Initialize a matrix to store the maximum value at each weight capacity
  value <- matrix(0, nrow = N + 1, ncol = W + 1)
  
  for (i in 1:N) {
    for (w in 1:W) {
      if (x$w[i] <= w) {
        value[i + 1, w] <- max(value[i, w], value[i, w - x$w[i]] + x$v[i])
      } else {
        value[i + 1, w] <- value[i, w]
      }
    }
  }
  
  return(value[N + 1, W])
}

# Example usage
knapsack_dynamic(items, W)

#' # Conclusion #' Each method presented in this vignette solves the knapsack problem using a different approach. The brute-force method guarantees an optimal solution but is slow for large inputs. The greedy heuristic is fast but may return suboptimal solutions. Dynamic programming offers a middle ground, ensuring optimal solutions while being computationally efficient for moderate input sizes.

#' *Question 2:* 
#' How much time does it takes to run the algorithm for n = 16 objects?
#'
#' **Answer:** 
Using the function `system.time` (which returns the difference between two proc.time calls, one before executing the given expression and the other one after)

 ```r
 system.time(brute_force_knapsack(x = knapsack_objects[1:16,], W = 3500))
 ```

#' *Question 2:* 
#' How long does it take to run the greedy algorithm for 1,000,000 objects?
#' 
#' **Answer:**  
#' To measure the time it takes for the greedy algorithm to run with 1,000,000 objects, we use the `system.time` function in R. The following code provides the time measurement:
 
 ```r
 system.time({
  result <- greedy_knapsack(knapsack_objects_large, W = 500000)
 })
 ```



